\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{times}
\usepackage{footnote}
%\usepackage{natbib}
\usepackage{caption}
\usepackage{float}
\usepackage[titles]{tocloft}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ragged2e} % 添加此宏包用于文本对齐
\usepackage{etoolbox} 
\usepackage{xcolor}
\usepackage{booktabs} % 提供更美观的表格线
\usepackage{siunitx}
\usepackage{makecell}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{fancyvrb} 
\usepackage[hidelinks]{hyperref}
\usepackage{url} % 用于处理 URL 格式更美观
\usepackage{listings}
\usepackage{xcolor}
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    columns=flexible,
    frame=single,
    backgroundcolor=\color{gray!10}
}
\usepackage[
    backend=biber,
    style=ieee,
    sorting=ynt
]{biblatex}
\addbibresource{references.bib}
\renewcommand*{\bibhang}{0pt} % 设置悬挂缩进为 0pt，即去除缩进




% 页边距设置
\geometry{a4paper, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm}
\renewcommand{\familydefault}{\rmdefault}



% 字体与段落格式
\renewcommand{\familydefault}{\rmdefault} % 使用 Roman 字体
\setlength{\parindent}{0pt} % 段落不缩进
\setlength{\parskip}{1em} % 段落间距
\singlespacing % 单倍行距
\justifying % 使用两端对齐

% Section 标题格式优化
\makeatletter
\renewcommand\section{\@startsection{section}{1}{\z@}%
    {-1ex \@plus -0.5ex \@minus -5ex} % 标题前的间距
    {1ex \@plus 0.5ex} % 标题后的间距
    {\normalfont\Large\bfseries}} % 标题字体：正常、加粗、较大
\makeatother

% 标题的字体和大小
\titleformat{\section}[block]{\fontsize{16pt}{18pt}\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}[block]{\fontsize{14pt}{16pt}\bfseries}{\thesubsection}{1em}{}

% 文档开始时设置段落缩进为0
\AtBeginDocument{\setlength{\parindent}{0pt}}

% 定义新命令：设置字体为蓝色 10pt
\newcommand{\tabletext}[1]{\textcolor{blue}{\fontsize{10pt}{12pt}\selectfont #1}}


\newenvironment{Abstract}
{\begin{center}
\section*{Abstract}
\end{center}
\begin{list}{}
    {\setlength{\leftmargin}{5pt}% 左边界设置为0
    \setlength{\parindent}{4em} % 设置段落首行缩进2个汉字宽度（对于英文一般是2em）
    \setstretch{1.8}
    \fontsize{12}{12}\selectfont 
    }}
    {\end{list}}
    
    




\begin{document}

\lstset{
    basicstyle=\ttfamily, % 缩小字体 + 等宽
    breaklines=true,            % 自动换行
    columns=flexible            % 优化对齐
}


% 标题页
\begin{titlepage}
    \centering
    \vspace{0.5cm}
    {\LARGE\bfseries Database - Driven Intelligent Restaurant Management System\par}
    \vspace{0.5cm}
    {\large by \par}
    \vspace{2cm}
    {\large Li Xinze\textsuperscript{1} (2330026083) \par}  
    {\large Li Jiale\textsuperscript{1} (2330026073) \par}  
    {\large Tian Zhiwen\textsuperscript{2} (2230033036)\par}  % Math
    {\large Yan Shan\textsuperscript{2} (2230033048) \par}    % Math 
    \vspace{1.5cm}
    {\large Group 6 Project (COMP3013 Database Management System) \par}
    \vspace{1.5cm}
    {\large Bachelor of Science (Honours) \par}
    \vspace{0.3cm}
    {\large in \par}
    \vspace{0.3cm}
    {\large \textsuperscript{1}Computer Science and Technology\par} 
    {\large \textsuperscript{2}Applied Mathematics \par}      % Math
    \vspace{1.5cm}
    {\large Supervised by\par}
    {\large Dr. Zhijian Li\par}
    \vspace{1cm}
    {\large Beijing Normal University - Hong Kong Baptist University\par}
    {\large \today\par}
\end{titlepage}





\newpage
\tableofcontents

\thispagestyle{empty} 
\pagenumbering{gobble}

% 正文
\newpage

\pagenumbering{arabic} % 设置页码格式为阿拉伯数字
\setcounter{page}{1}

%========================================================
\section{Project Description}

The purpose of this project is to develop a modern restaurant management system that addresses the common real-life challenges faced by restaurants in handling reservations, table allocation, and service coordination. The main problem being solved is the inefficiency and rigidity of traditional restaurant management systems, which make it difficult to track table availability, manage reservations, handle special customer requests, and keep staff updated in real time. This often leads to operational difficulties such as overbooking, underutilization of dining space, delayed service, and poor customer experience.

The difficulty of the problem lies in the need to coordinate multiple moving parts — reservations, table statuses, staff roles, menu management, and real-time updates — within a single system, all while minimizing human error. Additionally, the system must balance usability for both staff and customers, ensure data consistency, and remain adaptable to the dynamic nature of restaurant operations.

Abstractly, this problem can be described as a multi-user, multi-role resource allocation and workflow coordination challenge, where tables are the resources, reservations are the demands, and the system must efficiently match supply to demand in real time. This involves building a robust database with automation, providing intuitive interfaces, and designing a flexible architecture that supports diverse roles and workflows.

The major goal of this project is to create a dynamic, secure, and user-friendly restaurant management platform that streamlines operations, automates routine tasks, and improves the overall efficiency and experience for both staff and customers. By leveraging modern database techniques, automation through triggers, and role-based access control, the system aims to bridge the gap between outdated manual processes and the demands of contemporary restaurant operations.

%========================================================
\section{Our Dataset}
\subsection{Dataset}
The dataset contains synthetic records simulating real-world restaurant data:
\begin{itemize}
    \item Users (customers, receptionists, cleaners, admin)
    \item Tables and table types
    \item Orders with order details
    \item Menu items
    \item Comments/feedback
\end{itemize}

\subsection{Data collection}
Data was generated to cover common restaurant operations, including multiple users with different roles, reservations, cleaning tasks, and menu selections.

\subsection{Data preprocessing approaches}
We cleaned and standardized the data, ensuring consistency in table status, balance amounts, order timestamps, and valid relationships between entities.

%========================================================
\section{Database Design}
\subsection{Assumptions}
\begin{itemize}
    \item Each user has a distinct and exclusive role within the restaurant management system: admin, receptionist, cleaner, or customer. This role-based structure simplifies access control and ensures that users can only perform actions relevant to their job functions.
    \item Each order corresponds to one table, establishing a clear link between the customer's dining experience and the physical seating arrangement. Additionally, each table is assigned to a specific table type, helping with pricing, capacity management, and customer expectations.
    \item Customers can place orders and provide comments. Orders are central to the restaurant's operations, while comments serve as valuable feedback for improvement.
    \item Receptionists manage orders, including taking reservations, updating order statuses, and communicating with customers. Their role ensures a smooth customer experience from booking to meal completion.
    \item Cleaners are responsible for maintaining the cleanliness of dining areas by updating the cleaning status of tables. This ensures that tables are ready for the next customers in a timely manner.
    \item Admins manage table types, including creating new table types, updating their properties (e.g., price, description), and monitoring availability. This flexibility allows the restaurant to adapt to changing business needs and customer demands.
\end{itemize}

\subsection{Entity and Relationship Set}
\subsubsection{Entities}
\begin{itemize}
    \item \textbf{User}: Represents all individuals interacting with the system, storing common information such as uID, name, phone, password, user\_type, and balance. This entity provides a unified framework for managing user accounts and access rights.
    \item \textbf{Admin}: Inherits from the User entity and adds an AdminID to distinguish administrators. Admins have elevated privileges to manage the system, including table types, staff, and settings.
    \item \textbf{Receptionist}: Inherits from the User entity and is identified by Receptionist\_ID. Receptionists manage customer orders, take reservations, and update order statuses.
    \item \textbf{Cleaner}: Inherits from the User entity and is identified by Cleaner\_ID. Cleaners focus on maintaining the cleanliness of tables and updating their clean status.
    \item \textbf{Customer}: Inherits from the User entity and is identified by cID. Customers place orders, make reservations, and provide feedback.
    \item \textbf{Table}: Represents each physical table in the restaurant. It has a unique yID, links to a specific table type (ttID), and records its cleanliness status.
    \item \textbf{Table\_type}: Defines the different table types in the restaurant. It includes ttID, Name, Introduction, Price, Remain, and Img to provide details about each table type for customers and management.
    \item \textbf{Menu}: Stores details about each dish, including dID as the unique identifier, dish name, and price.
    \item \textbf{Order}: Captures each customer order with oID as the unique identifier, linking to the cID of the customer, the tID of the assigned table, the check-in status, the order price, and the order time.
    \item \textbf{Comment}: A weak entity dependent on the order, ensuring that comments are tied to specific orders.
\end{itemize}

\subsubsection{Relationships}
\begin{itemize}
    \item \textbf{User ISA Admin, Receptionist, Cleaner, Customer} \hfill \textit{ISA} \\
        This inheritance relationship models role-based access control. Each user is assigned one role, and common attributes (e.g., name, contact) are stored in the User entity, with role-specific attributes defined in sub-entities.
        
    \item \textbf{Admin Edit Table\_type (admin\_table\_type)} \hfill \textit{(1:N)} \\
        An admin can modify multiple table types, and each table type can be edited by an admin. This relationship supports dynamic configuration of table properties (e.g., capacity, pricing).
        
    \item \textbf{Receptionist Deal Order (receptionist\_order)} \hfill \textit{(1:N)} \\
        A receptionist can handle multiple orders, but each order is processed by exactly one receptionist, ensuring accountability for order management.
        
    \item \textbf{Cleaner Clean Table (cleaner\_table)} \hfill \textit{(M:N)} \\
        Multiple cleaners may be assigned to clean a table, and each cleaner can clean multiple tables, supporting collaborative cleaning schedules.
        
    \item \textbf{Customer Initiate Order (customer\_order)} \hfill \textit{(1:N)} \\
        A customer can place multiple orders, but each order is associated with a single customer. This relationship tracks customer dining history and preferences.
        
    \item \textbf{Table\_type Belong Table (table\_table\_type)} \hfill \textit{(1:N)} \\
        A table type (e.g., VIP, standard) can have multiple instances, but each table belongs to exactly one type. This relationship supports pricing and resource allocation.
        
    \item \textbf{Order Select Menu (orders\_dishes)} \hfill \textit{(M:N)} \\
        An order can include multiple dishes, and each dish can appear in multiple orders. This relationship is modeled via the \texttt{orders\_dishes} associative table, which records the quantity and customization of each dish.
        
    \item \textbf{Order Occupy Table (order\_table)} \hfill \textit{(1:1)} \\
        Each order is assigned to a specific table during the dining period, ensuring exclusive use of the table. This relationship is vital for managing table availability.
        
    \item \textbf{Order Create Comment (order\_comment)} \hfill \textit{(1:1)} \\
        Comments are weak entities dependent on orders. Each comment must reference an existing order, ensuring that feedback is tied to specific dining experiences.
\end{itemize}



\subsection{ER diagram}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{ER.png} % 这里以示例图片为例，你需要替换为实际的图片文件名
    \caption{ER diagram}
    \label{fig:example}
\end{figure}

The ER diagram visually represents the entities and relationships in the database. At the center is the user entity, with inheritance relationships branching out to admin, receptionist, cleaner, and customer entities, clearly indicating the role - based structure. The table entity is connected to the table type entity through a one - to - many relationship, signifying that multiple tables can belong to the same table type. The order entity acts as a central hub, connecting to the user (customer), table, and menu entities, which effectively reflects the complex interactions during the dining process. The comment entity is linked to the order entity, emphasizing its dependence on the existence of an order.



\subsection{Functional Dependencies}
The following functional dependencies represent the relationships between attributes in the database schema, capturing the rules of attribute determination based on keys:

\begin{itemize}
    \item \( \text{uID} \rightarrow \text{name, phone, , password, user\_type, balance} \)  \\
    For any user (\( \text{uID} \)), the associated name, phone number, user type (role), and balance can be uniquely determined. This applies to all user types (Admin, Receptionist, Cleaner, Customer).

    \item \( \text{tID} \rightarrow \text{ttID, clean\_state} \)  \\
    A specific table (\( \text{tID} \)) uniquely determines the table type (\( \text{TtID} \)) and its cleanliness state (\( \text{Clean\_state} \)). Each table has a designated type and cleanliness status.

    \item \( \text{oID} \rightarrow \text{cID, tID, receptionist\_ID, check\_in\_state, price, order\_time} \)  \\
    For an order (\( \text{oID} \)), the customer (\( \text{cID} \)), table (\( \text{tID} \)), receptionist (\( \text{Receptionist\_ID} \)), check-in state, price, and order time are uniquely determined. This describes the details of a specific order.

    \item \( \text{dID} \rightarrow \text{dname, dprice} \)  \\
    A dish (\( \text{dID} \)) uniquely determines its name (\( \text{Dname} \)) and price (\( \text{Dprice} \)). Each dish has a distinct identifier and corresponding attributes.

    \item \( (\text{oID}, \text{dID}) \rightarrow \text{Quantity} \)  \\
    A combination of order (\( \text{oID} \)) and dish (\( \text{dID} \)) uniquely determines the quantity  options for that specific dish in the order. This models the many-to-many relationship between orders and dishes.

    \item \( \text{ttID} \rightarrow \text{name, introduction, price, remain, img} \)  \\
    A table type (\( \text{ttID} \)) uniquely determines its name, introduction, price, remaining capacity (\( \text{Remain} \)), and image (\( \text{Img} \)). Each table type (e.g., VIP, Standard) has associated details that are determined by its type.
\end{itemize}

\subsection{Schemas}
\begin{itemize}
    \item user (\underline{uID}, name, phone, password, user\_type, balance)
    \item admin (\underline{adminID}, uID) \\.   \textit{[FK: uID $\rightarrow$ User]}
    \item Receptionist (\underline{receptionist\_ID}, uID)\\.   \textit{[FK: uID $\rightarrow$ User]}
    \item cleaner (\underline{cleaner\_ID}, uID)\\.   \textit{[FK: uID $\rightarrow$ User]}
    \item customer (\underline{cID}, uID)\\  \textit{[FK: uID $\rightarrow$ User]}
    \item table (\underline{tID}, ttID, clean\_state)\\.  \textit{[FK: ttID $\rightarrow$ Table\_type]}
    \item table\_type (\underline{ttID}, name, introduction, price, remain, img)
    \item menu (\underline{dID}, dname, dprice)
    \item ord (\underline{oID}, cID, tID, receptionist\_ID, check\_in\_state, price, order\_time)\\.   \textit{[FKs: cID $\rightarrow$ Customer, tID $\rightarrow$ Table, receptionist\_ID $\rightarrow$ Receptionist]}
    \item comment (\underline{cID}, \underline{oID}, comment)\\  \textit{[Composite PK, FKs: cID $\rightarrow$ Customer, oID $\rightarrow$ Order]}
    \item admin\_Table\_type (\underline{adminID}, \underline{ttID}, edit\_time)\\  \textit{[Composite PK, FKs: adminID $\rightarrow$ Admin, ttID $\rightarrow$ Table\_type]}
    \item cleaner\_Table (\underline{cleanerID}, \underline{tID}, clean\_time)\\  \textit{[Composite PK, FKs: cleanerID $\rightarrow$ Cleaner, tID $\rightarrow$ Table]}
    \item orders\_dishes (\underline{oID}, \underline{dID}, quantity)\\  \textit{[Composite PK, FKs: oID $\rightarrow$ ord, dID $\rightarrow$ Menu]}
\end{itemize}

\subsection{Primary Keys}
\begin{itemize}
    \item user: \underline{uID}
    \item admin: \underline{adminID}
    \item receptionist: \underline{receptionist\_ID}
    \item cleaner: \underline{cleaner\_ID}
    \item customer: \underline{cID}
    \item table: \underline{tID}
    \item table\_type: \underline{ttID}
    \item menu: \underline{dID}
    \item order: \underline{oID}
    \item comment: \underline{cID}, \underline{oID}
    \item admin\_table\_type: \underline{adminID}, \underline{ttID}
    \item cleaner\_Table: \underline{cleanerID}, \underline{tID}
    \item orders\_dishes: \underline{oID}, \underline{dID}
\end{itemize}

\subsection{Normal Forms and Analysis}

All schemas are in \textbf{Third Normal Form (3NF)} because:
\begin{itemize}
    \item Each relation has a primary key.
    \item All non-prime attributes are fully functionally dependent on the primary key.
    \item There are no transitive dependencies.
\end{itemize}

\textbf{Explanation examples:}
\begin{itemize}
    \item \textbf{User}: \underline{uID} is the primary key; attributes such as name, phone, user\_type, and balance depend only on \underline{uID}.
    \item \textbf{Table}: \underline{tID} is the primary key; attributes like clean\_state and ttID depend only on \underline{tID}.
    \item \textbf{Order}: \underline{oID} is the primary key; attributes such as cID, tID, receptionist\_ID, check\_in\_state, price, and order\_time depend only on \underline{oID}.
    \item \textbf{Orders\_Dishes}: (\underline{oID}, \underline{dID}) as the composite key; attributes such as quantity depend on both \underline{oID} and \underline{dID}.
\end{itemize}

\textbf{No decomposition needed}, as all schemas already satisfy 3NF. If decomposition were necessary (e.g., if a non-prime attribute depended on another non-prime attribute), we would apply the standard 3NF decomposition steps:
\begin{enumerate}
    \item Identifying partial or transitive dependencies.
    \item Splitting the relation into smaller relations, preserving dependencies and keys.
    \item Ensuring lossless join and dependency preservation.
\end{enumerate}




\subsection{Data insertion}
During the data entry stage, the database simulates the large-scale data environment of hotel operations. For instance, 50,000 pieces of user data were inserted into the system, including one administrator, 200 cleaners, 200 receptionists, and the rest of the customers. At the same time, data for a total of 50,000 orders over the past three years were also inserted. Each order contains information such as the order time, current status, and price, which is intended to be used by the front desk staff for managing customer reservations and settlements. Additionally, five types of tables were provided for customers to choose from, totaling 400 tables, and the hygiene conditions of each table were marked so that the cleaners would know which tables needed cleaning. We also set 82 dishes on the menu for customers to order.




%========================================================


\section{Features}

\subsection{Trigger: \texttt{update\_order\_total\_price\_on\_dish\_change}}

\subsection*{Table: \texttt{orders\_dishes}}
This trigger updates the total price of an order whenever there are changes to its associated dishes.

\subsubsection*{AFTER INSERT}

Triggered after a new record is inserted into the \texttt{orders\_dishes} table:
\begin{itemize}
    \item Retrieves the price of the inserted dish from the \texttt{menu} table.
    \item Increases the total price of the corresponding order in the \texttt{ord} table by the product of quantity and dish price.
\end{itemize}

\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_orders_dishes_after_insert_update_order_price
AFTER INSERT ON orders_dishes
FOR EACH ROW
BEGIN
    DECLARE dish_price DECIMAL(10,2);
    SELECT price INTO dish_price FROM menu WHERE dID = NEW.dID;
    UPDATE ord
    SET price = price + (NEW.quantity * dish_price)
    WHERE oID = NEW.oID;
END;
//
DELIMITER ;
\end{lstlisting}

\subsubsection*{AFTER UPDATE}
Triggered after a record in \texttt{orders\_dishes} is updated:
\begin{itemize}
    \item Fetches the old and new dish prices from the \texttt{menu} table.
    \item Updates the total price of the order by subtracting the old amount and adding the new amount.
\end{itemize}

\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_orders_dishes_after_update_update_order_price
AFTER UPDATE ON orders_dishes
FOR EACH ROW
BEGIN
    DECLARE old_dish_price DECIMAL(10,2);
    DECLARE new_dish_price DECIMAL(10,2);

    SELECT price INTO old_dish_price FROM menu WHERE dID = OLD.dID;
    SELECT price INTO new_dish_price FROM menu WHERE dID = NEW.dID;

    UPDATE ord
    SET price = price - (OLD.quantity * old_dish_price) + (NEW.quantity * new_dish_price)
    WHERE oID = NEW.oID;
END;
//
DELIMITER ;
\end{lstlisting}

\subsubsection*{AFTER DELETE}
Triggered after a record is deleted from \texttt{orders\_dishes}:
\begin{itemize}
    \item Retrieves the dish price from the \texttt{menu} table.
    \item Decreases the total price of the associated order by the removed item's cost.
\end{itemize}

\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_orders_dishes_after_delete_update_order_price
AFTER DELETE ON orders_dishes
FOR EACH ROW
BEGIN
    DECLARE dish_price DECIMAL(10,2);
    SELECT price INTO dish_price FROM menu WHERE dID = OLD.dID;
    UPDATE ord
    SET price = price - (OLD.quantity * dish_price)
    WHERE oID = OLD.oID;
END;
//
DELIMITER ;
\end{lstlisting}

\subsection{Trigger: \texttt{update\_table\_status\_on\_order\_completion}}

\subsection*{Table: \texttt{ord}}
This trigger updates the status of the table associated with an order once the order is completed.

\begin{itemize}
    \item Triggered after an update to the \texttt{ord} table.
    \item If the \texttt{check\_in\_status} changes to \texttt{completed}:
    \begin{itemize}
        \item Finds the table associated with the order via the \texttt{order\_table} relation.
        \item Updates the corresponding record in the \texttt{table} table to set \texttt{clean\_status} to \texttt{dirty}.
    \end{itemize}
\end{itemize} 

\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_ord_after_update_set_table_dirty
AFTER UPDATE ON ord
FOR EACH ROW
BEGIN
    DECLARE v_tID INT;

    IF NEW.check_in_status = 'completed' AND OLD.check_in_status <> 'completed' THEN
        SELECT tID INTO v_tID FROM order_table WHERE oID = NEW.oID LIMIT 1;
        IF v_tID IS NOT NULL THEN
            UPDATE `table`
            SET clean_status = 'dirty'
            WHERE tID = v_tID;
        END IF;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}

\section{Trigger: \texttt{manage\_table\_type\_remain}}

\subsection*{Table: \texttt{table\_table\_type}}
These triggers maintain the remaining count of tables per type in the \texttt{table\_type} table.

\subsubsection*{AFTER INSERT}
\begin{itemize}
    \item Increments the \texttt{remain} field for the relevant \texttt{ttID} by 1.
\end{itemize}

\subsubsection*{AFTER INSERT}
\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_table_table_type_after_insert_update_remain
AFTER INSERT ON table_table_type
FOR EACH ROW
BEGIN
    IF NEW.ttID IS NOT NULL THEN
        UPDATE table_type
        SET remain = COALESCE(remain, 0) + 1
        WHERE ttID = NEW.ttID;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}

\subsubsection*{AFTER DELETE}
\begin{itemize}
    \item Decrements the \texttt{remain} field for the relevant \texttt{ttID} by 1, ensuring it doesn't go below 0.
\end{itemize}
\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_table_table_type_after_delete_update_remain
AFTER DELETE ON table_table_type
FOR EACH ROW
BEGIN
    IF OLD.ttID IS NOT NULL THEN
        UPDATE table_type
        SET remain = GREATEST(0, COALESCE(remain, 1) - 1)
        WHERE ttID = OLD.ttID;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}

\subsubsection*{AFTER UPDATE}
\begin{itemize}
    \item If the \texttt{ttID} is changed:
    \begin{itemize}
        \item Decreases the remaining count of the old \texttt{ttID}.
        \item Increases the remaining count of the new \texttt{ttID}.
    \end{itemize}
\end{itemize}
\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_table_table_type_after_update_update_remain
AFTER UPDATE ON table_table_type
FOR EACH ROW
BEGIN
    IF OLD.ttID <> NEW.ttID THEN
        IF OLD.ttID IS NOT NULL THEN
            UPDATE table_type
            SET remain = GREATEST(0, COALESCE(remain, 1) - 1)
            WHERE ttID = OLD.ttID;
        END IF;
        IF NEW.ttID IS NOT NULL THEN
            UPDATE table_type
            SET remain = COALESCE(remain, 0) + 1
            WHERE ttID = NEW.ttID;
        END IF;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}

\subsection*{Table: \texttt{ord} -- Triggering via order status changes}

\subsubsection*{AFTER UPDATE}
This trigger adjusts the remaining number of tables per type based on changes to an order's \texttt{check\_in\_status}:

\begin{itemize}
    \item When changing to \texttt{occupying}:
    \begin{itemize}
        \item Decreases the \texttt{remain} field of the corresponding table type.
    \end{itemize}
    \item When changing from \texttt{occupying} to \texttt{completed} or \texttt{pending}:
    \begin{itemize}
        \item Increases the \texttt{remain} field of the corresponding table type.
    \end{itemize}
\end{itemize}

\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_ord_status_change_update_table_type_remain
AFTER UPDATE ON ord
FOR EACH ROW
BEGIN
    DECLARE v_tID INT;
    DECLARE v_ttID INT;

    SELECT tID INTO v_tID FROM order_table WHERE oID = NEW.oID LIMIT 1;

    IF v_tID IS NOT NULL THEN
        SELECT ttID INTO v_ttID FROM table_table_type WHERE tID = v_tID LIMIT 1;

        IF v_ttID IS NOT NULL THEN
            IF (OLD.check_in_status <> 'occupying' OR OLD.check_in_status IS NULL)
                AND NEW.check_in_status = 'occupying' THEN
                UPDATE table_type
                SET remain = GREATEST(0, COALESCE(remain, 1) - 1)
                WHERE ttID = v_ttID;
            ELSEIF OLD.check_in_status = 'occupying'
                AND (NEW.check_in_status = 'completed' OR NEW.check_in_status = 'pending') THEN
                UPDATE table_type
                SET remain = COALESCE(remain, 0) + 1
                WHERE ttID = v_ttID;
            END IF;
        END IF;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}

\subsubsection*{AFTER INSERT}
\begin{itemize}
    \item If the new order's \texttt{check\_in\_status} is \texttt{occupying}, the corresponding table type's \texttt{remain} count is decreased by 1.
\end{itemize}
\begin{lstlisting}
DELIMITER //
CREATE TRIGGER trg_ord_after_insert_update_table_type_remain
AFTER INSERT ON ord
FOR EACH ROW
BEGIN
    DECLARE v_tID INT;
    DECLARE v_ttID INT;

    IF NEW.check_in_status = 'occupying' THEN
        SELECT tID INTO v_tID FROM order_table WHERE oID = NEW.oID LIMIT 1;
        IF v_tID IS NOT NULL THEN
            SELECT ttID INTO v_ttID FROM table_table_type WHERE tID = v_tID LIMIT 1;
            IF v_ttID IS NOT NULL THEN
                UPDATE table_type
                SET remain = GREATEST(0, COALESCE(remain, 1) - 1)
                WHERE ttID = v_ttID;
            END IF;
        END IF;
    END IF;
END;
//
DELIMITER ;
\end{lstlisting}


\subsection{BLOB}
BLOB fields are used in the Table\_type entity to store table type images, enhancing the visual presentation for customers.


%========================================================
\section{Access Control}

Each page checks the user's role and login status to control access authority and ensure that only authorized users can perform certain actions.

\subsection{User Registration (\texttt{register.html})}

The registration form captures user details and stores them in the database. Upon submission:

\begin{itemize}
    \item User inputs are validated via \texttt{POST} request to \texttt{reg-check.php}.
    \item Passwords are checked for matching values.
    \item \texttt{usrType} determines access privileges:
    \begin{itemize}
        \item \texttt{receptionist}: Full reservation management.
        \item \texttt{customer}: View/reserve tables.
        \item \texttt{cleaner}: Access cleaning schedules.
    \end{itemize}
    \item Session variables (e.g., \texttt{\$\_SESSION['usrType']}) are set post-login.
\end{itemize}

\subsection{User Login (\texttt{login.html})}

The login page allows registered users to authenticate themselves and gain access to role-specific dashboards. User credentials are securely transmitted via a \texttt{POST} request to \texttt{login-check.php} for server-side verification. Upon successful authentication, user session data is stored to maintain authentication state and role information across pages.

The login form includes the following components:

\begin{itemize}
    \item \textbf{UserID Field}: Required input for the user's unique identifier (autogenerated during registration).
    \item \textbf{Password Field}: Masked input for the user's password (required).
    \item \textbf{Login Button}: Submits the form data to \texttt{login-check.php}.
    \item \textbf{Registration Link}: Redirects new users to \texttt{register.html} if they need to create an account.
\end{itemize}

The server-side script \texttt{login-check.php} should perform the following actions:

\begin{enumerate}
    \item Validate UserID and password against database records.
    \item Retrieve user role (\texttt{receptionist}, \texttt{customer}, or \texttt{cleaner}) from the database.
    \item Start a session and store user information:
    \begin{itemize}
        \item \texttt{\$\_SESSION['userID']}: Unique identifier for the user.
        \item \texttt{\$\_SESSION['usrType']}: User role determining access privileges.
        \item \texttt{\$\_SESSION['loggedin']}: Boolean flag to track authentication status.
    \end{itemize}
    \item Redirect user to their role-specific dashboard:
    \begin{itemize}
        \item Receptionists: \texttt{receptionist-dashboard.php}.
        \item Customers: \texttt{customer-dashboard.php}.
        \item Cleaners: \texttt{cleaner-dashboard.php}.
    \end{itemize}
    \item Handle authentication failures with appropriate error messages.
\end{enumerate}

Session management is critical for maintaining security and access control. Each subsequent page must include session validation to ensure only authenticated users with the correct role can access restricted content.

\subsection{Customer Pages}

\subsubsection{home.php}
Displays all available table types. The top navigation menu includes links to:
\begin{itemize}
    \item \texttt{book.php}
    \item \texttt{credit.php}
    \item \texttt{order.php}
    \item \texttt{logout.php}
\end{itemize}
Clicking on a specific table redirects to \texttt{book.php}.  
Clicking the ``Orders'' button redirects to \texttt{order.php}.  
Clicking the ``Wallet'' button redirects to \texttt{credit.php}.

\subsubsection{book.php}
Shows details about a specific table type, including:
\begin{itemize}
    \item Reviews
    \item Prices
    \item Available table count
\end{itemize}
If the user does not have sufficient balance, the purchase button will not be displayed.  
After clicking the purchase button, the request is submitted via \texttt{POST} to \texttt{book-check.php} for validation. Successful bookings update the user's order information in the database.

\subsubsection{order.php}
Lists all of the user's past and current orders.

\subsubsection{order-detail.php}
Displays details of a specific order, such as:
\begin{itemize}
    \item Date
    \item Price
    \item Table type
    \item Table number
\end{itemize}
A comment box is provided for feedback.  
Comments are submitted via \texttt{POST} to \texttt{comment-check.php} for validation.  
If a review is created, it is submitted via \texttt{POST} to \texttt{submit-review.php} for storage in the database.

\subsubsection{credit.php}
Displays the user's current wallet balance and provides an input field for adding funds.  
Top-ups are submitted via \texttt{POST} to \texttt{charge-check.php}.

\subsubsection{add-dish-to-order.php}

This page lets logged-in customers add dishes to active (\texttt{occupying}) orders.

\textbf{Key logic:}
\begin{itemize}
    \item Check \texttt{order\_id} (GET) and \texttt{\$\_SESSION['userID']}; redirect to login if needed.
    \item Retrieve order details (status, total, balance) from \texttt{Ord}, \texttt{Customer\_Order}, \texttt{User}.
    \item Allow dish addition only if order status is \texttt{occupying}.
    \item Load menu items from \texttt{Menu}; list current order items from \texttt{Orders\_Dishes}.
\end{itemize}

\textbf{On submission:}
\begin{itemize}
    \item Get dish ID and quantity; enforce minimum of 1.
    \item Check if total exceeds balance; show alert if insufficient.
    \item Insert or update dish using \texttt{ON DUPLICATE KEY UPDATE}.
    \item Redirect to refresh the page and show updates.
\end{itemize}

\textbf{Page layout:}
\begin{itemize}
    \item Header: system name, links (\texttt{home.php}, \texttt{credit.php}, \texttt{order.php}, \texttt{logout.php}).
    \item Main: dish selection form, current order summary.
    \item Footer: team credits.
\end{itemize}

\subsection{Administrator Page (admin.php)}
Administrators can edit user and table type information. All actions are handled by \texttt{admin-actions.php}.

\subsection{Receptionist Page (receptionist.php)}
Receptionists manage check-ins and check-outs. By entering the user's ID, the associated table is retrieved.  
Check-in and check-out actions are triggered by clicking buttons and submitted via \texttt{POST} to \texttt{recept-check.php}.

\subsection{Cleaner Page (cleaner.php)}
Cleaners can:
\begin{itemize}
    \item View tables that need cleaning.
    \item Mark tables as cleaned.
\end{itemize}
A list of tables awaiting cleaning is displayed.  
Clicking the ``Clean'' button removes the table from the list.

\subsection{Logout Page (logout.php)}
Clears session data and logs the user out.\\







%========================================================
\section{Implemented Functions}

This section summarizes all front-end and back-end functions developed in the system.

\subsection{Front-End Functions}

\begin{itemize}
    \item \textbf{register.html} — User registration form.
    \item \textbf{login.html} — User login form.
    \item \textbf{home.php} — Displays available table types with navigation links.
    \item \textbf{book.php} — Shows table type details; enables booking if balance is sufficient.
    \item \textbf{order.php} — Displays past and current orders.
    \item \textbf{order-detail.php} — Shows detailed order information; allows comments and reviews.
    \item \textbf{credit.php} — Displays wallet balance; provides top-up form.
    \item \textbf{add-dish-to-order.php} — Provides a form to select and add dishes to active orders.
    \item \textbf{admin.php} — Admin panel for managing users and table types.
    \item \textbf{receptionist.php} — Interface for managing check-in and check-out operations.
    \item \textbf{cleaner.php} — Lists tables to clean; provides one-click clean update.
    \item \textbf{logout.php} — Logs out the user and clears session data.
\end{itemize}

\subsection{Back-End Functions}

\begin{itemize}
    \item \textbf{reg-check.php} — Validates registration form, stores user data in the database.
    \item \textbf{login-check.php} — Validates login credentials, starts user session.
    \item \textbf{book-check.php} — Validates and processes table reservations.
    \item \textbf{charge-check.php} — Processes wallet top-ups.
    \item \textbf{comment-check.php} — Handles user comments on orders.
    \item \textbf{submit-review.php} — Stores user reviews in the database.
    \item \textbf{admin-actions.php} — Handles admin operations like fetching and updating users, tables, and table types.
    \item \textbf{recept-check.php} — Manages receptionist operations for check-in and check-out.
    \item \textbf{add-dish-to-order.php} (PHP section) — Processes dish additions, validates balance, updates the database.
\end{itemize}

%========================================================
\section{SQL Codes and Explanations}

\subsection{User Registration}
\begin{lstlisting}
INSERT INTO User (uID, name, phone, password, user_type, balance)
VALUES (NULL, 'username', '1234567890', 'hashed_password', 'customer', 0.0);

INSERT INTO Customer (cID, uID)
VALUES (NULL, LAST_INSERT_ID());
\end{lstlisting}
\textbf{Explanation:} Inserts a new user into the User table and links to the Customer table.

\subsection{User Login}
\begin{lstlisting}
SELECT * 
FROM User 
WHERE uID = '$userID' AND password = '$password';
\end{lstlisting}
\textbf{Explanation:} Checks username and password for authentication.

\subsection{List All Table Types}
\begin{lstlisting}
SELECT * 
FROM Table_type 
WHERE remain > 0;
\end{lstlisting}
\textbf{Explanation:} Retrieves all available table types with remaining seats.

\subsection{Table Details}
\begin{lstlisting}
SELECT * 
FROM Table_type 
WHERE ttID = '$ttID';

SELECT comment FROM Comment WHERE oID IN (
    SELECT oID FROM Ord WHERE tID IN (
        SELECT tID FROM `Table` WHERE ttID = '$ttID'
    )
);
\end{lstlisting}
\textbf{Explanation:} Retrieves table details and associated user comments.

\subsection{Create Order}
\begin{lstlisting}
INSERT INTO Ord (oID, cID, tID, receptionist_ID, check_in_status, price, order_time)
VALUES (NULL, '$cID', '$tID', '$receptionistID', 'occupying', 0.0, NOW());
\end{lstlisting}
\textbf{Explanation:} Creates a new order entry in the system.

\subsection{List Orders}
\begin{lstlisting}
SELECT * 
FROM Ord 
WHERE cID = '$cID';
\end{lstlisting}
\textbf{Explanation:} Retrieves all orders for a specific user.

\subsection{Query Wallet Balance}
\begin{lstlisting}
SELECT balance 
FROM User 
WHERE uID = '$userID';
\end{lstlisting}
\textbf{Explanation:} Retrieves the current balance of the user.

\subsection{Update Wallet Balance}
\begin{lstlisting}
UPDATE User SET balance = balance + $amount WHERE uID = '$userID';
\end{lstlisting}
\textbf{Explanation:} Updates the user's wallet balance after recharge.

\subsection{Retrieve User Information}
\begin{lstlisting}
SELECT * 
FROM User 
WHERE uID = '$userID';
\end{lstlisting}
\textbf{Explanation:} Fetches full user details using their ID.

\subsection{Table Management}
\begin{lstlisting}
SELECT *
 FROM `Table` 
 WHERE tID = '$tID';

UPDATE `Table` SET clean_status = '$status' WHERE tID = '$tID';
\end{lstlisting}
\textbf{Explanation:} Retrieves or updates table cleaning status.

\subsection{Table Type Management}
\begin{lstlisting}
SELECT * 
FROM Table_type 
WHERE ttID = '$ttID';

UPDATE Table_type SET introduction = '$intro', price = $price, remain = $remain
WHERE ttID = '$ttID';
\end{lstlisting}
\textbf{Explanation:} Retrieves or modifies table type information.

\subsection{Order Management}
\begin{lstlisting}
SELECT * 
FROM Ord 
WHERE oID = '$oID';

UPDATE Ord SET check_in_status = '$status', price = $price WHERE oID = '$oID';
\end{lstlisting}
\textbf{Explanation:} Retrieves or updates details of a specific order.

\subsection{Find Tables Requiring Cleaning}
\begin{lstlisting}
SELECT * 
FROM `Table` 
WHERE clean_status = 'dirty';
\end{lstlisting}
\textbf{Explanation:} Finds all tables marked as needing cleaning.

\subsection{Update Table Cleaning Status}
\begin{lstlisting}
UPDATE `Table` SET clean_status = 'clean' WHERE tID = '$tID';
\end{lstlisting}
\textbf{Explanation:} Marks a table as cleaned.

\subsection{Add Dish to Order}
\begin{lstlisting}
INSERT INTO Orders_Dishes (oID, dID, quantity)
VALUES ('$oID', '$dID', $quantity)
ON DUPLICATE KEY UPDATE quantity = quantity + $quantity;
\end{lstlisting}
\textbf{Explanation:} Adds a dish to an existing order or updates its quantity.

\subsection{Trigger: Update Order Total}
\begin{lstlisting}
CREATE TRIGGER update_order_total
AFTER INSERT ON Orders_Dishes
FOR EACH ROW
BEGIN
    UPDATE Ord SET price = price + (
        SELECT dprice * NEW.quantity FROM Menu WHERE dID = NEW.dID
    ) WHERE oID = NEW.oID;
END;
\end{lstlisting}
\textbf{Explanation:} Automatically updates the total price when new dishes are added.


%========================================================
\section{Contribution}

\begin{table}[H]
\centering
\caption{Team Member Contributions}
\begin{tabular}{llp{10cm}}
\toprule
\textbf{Name} & \textbf{Student ID} & \textbf{Contribution} \\
\midrule
Li Xinze & 2330026083 & Frontend and backend of: login/logout, registration, home, book, credit, order/order-detail, admin, receptionist, cleaner, and trigger implementation, PPT part4\\
Li Jiale & 2330026073 & Frontend and backend of:  menu modules, PPT part3 \\
Tian Zhiwen & 2230033036 & ER diagram design, trigger implementation, and report writing, PPT part2\\
Yan Shan & 2230033048 & Dataset insertion, PPT part1\\

\bottomrule
\end{tabular}
\end{table}




\end{document}
